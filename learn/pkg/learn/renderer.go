package learn

import (
	"bytes"
	"errors"
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"strings"

	"evylang.dev/evy/pkg/cli"
	"evylang.dev/evy/pkg/evaluator"
	"evylang.dev/evy/pkg/md"
	"evylang.dev/evy/pkg/parser"
	"golang.org/x/tools/txtar"
	"rsc.io/markdown"
)

// Renderer generates the result output for automated question-answer
// verification.
//
// The result output is either plain text or SVG image content.
//
// The renderer may be generated from Evy source code in linked files or code
// blocks or from pre-prepared SVG files or inline plain text output text.
type Renderer interface {
	RenderOutput() string         // text or SVG output
	RenderHTML(buf *bytes.Buffer) // evy source, text or SVG output
}

// ResultType indicates the type of output generated by a Renderer.
type ResultType uint

// ResultType constants.
const (
	UnknownOutput ResultType = iota
	TextOutput
	SVGOutput
)

// AsRenderer converts a markdown code block, image or link into a Renderer if
// possible.
//
// Markdown code blocks with an `evy` info tag are interpreted as Evy source
// code that can generate text or image/SVG output. Code blocks with an empty
// info tag are interpreted directly as text output.
//
// Markdown images need to have a relative URL ending in ".evy.svg". The image
// text has to be `question` or `answer`.
//
// Markdown links need to be to relative links to `.evy` files. The link text
// needs to be `question` or `answer`.The The link title indicates whether to
// use evy file as source file, generate text or image/SVG output from it. It
// needs to be one of:
//
//	evy:source | evy:svg | evy:text
//
// Code blocks, links and images that don't meet the conditions listed above
// are ignored. In this case AsRenderer returns nil, nil.
func AsRenderer(block markdown.Block, field fieldType, filename string) (Renderer, error) {
	if cb, ok := block.(*markdown.CodeBlock); ok {
		return rendererFromCodeblock(cb)
	}
	if text := toText(block); text != nil && len(text.Inline) == 1 {
		return rendererFromInline(text.Inline[0], field, filename)
	}
	return nil, nil
}

func rendererFromCodeblock(cb *markdown.CodeBlock) (Renderer, error) {
	if cb.Info == "evy" {
		text := strings.Join(cb.Text, "\n") + "\n"
		return newEvySource(text), nil
	}
	if cb.Info == "" {
		return newTextContent(cb), nil
	}
	return nil, nil
}

func rendererFromInline(inline markdown.Inline, field fieldType, filename string) (Renderer, error) {
	mdImg, ok := inline.(*markdown.Image)
	if ok && strings.HasSuffix(mdImg.URL, ".evy.svg") {
		if err := ensureField(mdImg.Inner, field); err != nil {
			return nil, fmt.Errorf("%w (image: %s)", err, md.Undecorate(mdImg))
		}
		return newSVGContentFromFile(filepath.Join(filepath.Dir(filename), mdImg.URL))
	}
	link, ok := inline.(*markdown.Link)
	if ok && strings.HasPrefix(link.Title, "evy:") {
		if err := ensureField(link.Inner, field); err != nil {
			return nil, fmt.Errorf("%w (link: %s)", err, md.Undecorate(link))
		}
		ResultType, err := getResultTypeFromLink(link)
		if err != nil {
			return nil, fmt.Errorf("%w (link: %s)", err, md.Undecorate(link))
		}
		targetFilename := filepath.Join(filepath.Dir(filename), link.URL)
		return newRendererFromEvyFile(targetFilename, ResultType)
	}
	if inlineCode, ok := inline.(*markdown.Code); ok {
		content := inlineCode.Text + "\n"
		return TextContent(content), nil
	}
	return nil, nil
}

func ensureField(inner []markdown.Inline, field fieldType) error {
	if len(inner) != 1 {
		return fmt.Errorf("%w: found %d inner elements, expected 1", ErrBadMarkdownStructure, len(inner))
	}
	got := md.Undecorate(inner[0])
	want := fieldTypeToString[field]
	if got != want {
		return fmt.Errorf("%w: expected %q text, found %q", ErrBadMarkdownStructure, want, got)
	}
	return nil
}

// SVGContent represents SVG image content.
type SVGContent string

func newSVGContentFromFile(filename string) (SVGContent, error) {
	b, err := os.ReadFile(filename)
	if err == nil {
		return SVGContent(b), nil
	}
	if !errors.Is(err, fs.ErrNotExist) {
		return "", err
	}
	evySourcePath := strings.TrimSuffix(filename, ".svg")
	b, err2 := os.ReadFile(evySourcePath)
	if err2 != nil {
		return "", fmt.Errorf("error reading evy source for image: %w: %w (%s)", err, err2, filename)
	}
	svgData := runEvy(string(b), SVGOutput)
	if err2 := os.WriteFile(filename, []byte(svgData), 0o666); err2 != nil {
		return "", fmt.Errorf("error writing svg output for evy source: %w: %w (%s)", err, err2, filename)
	}
	return SVGContent(svgData), nil
}

// RenderOutput returns the SVG content as a string.
func (s SVGContent) RenderOutput() string {
	return string(s)
}

// RenderHTML prints the SVG content as is.
func (s SVGContent) RenderHTML(buf *bytes.Buffer) {
	buf.WriteString(string(s))
}

type evySource struct {
	source     string
	ResultType ResultType
	output     string // cached output
}

func newEvySource(text string) *evySource {
	return &evySource{source: text}
}

// RenderOutput executes the Evy source code and returns the text or image output as
// a string.
func (s *evySource) RenderOutput() string {
	if s.output == "" {
		s.output = runEvy(s.source, s.ResultType)
	}
	return s.output
}

// RenderHTML prints evy source code.
func (s *evySource) RenderHTML(buf *bytes.Buffer) {
	buf.WriteString(`<pre><code class="language-evy">`)
	buf.WriteString(removeCommentTags(s.source))
	buf.WriteString("</code></pre>\n")
}

func removeCommentTags(s string) string {
	lines := strings.Split(s, "\n")
	for i, line := range lines {
		lines[i] = strings.TrimSuffix(line, " //levy:blank")
	}
	return strings.Join(lines, "\n")
}

func removeTaggedPrint(s string) string {
	lines := strings.Split(s, "\n")
	for i, line := range lines {
		if strings.HasSuffix(line, " //levy:blank") && strings.HasPrefix(line, "print ") {
			lines[i] = "print"
		}
	}
	return strings.Join(lines, "\n")
}

func newTxtarContent(filename string, resultType ResultType) (Renderer, error) {
	b, err := os.ReadFile(filename)
	if err != nil {
		return nil, err
	}
	archive := txtar.Parse(b)
	m := map[string]bool{}
	for _, file := range archive.Files {
		content := string(file.Data)
		if m[content] {
			return nil, fmt.Errorf("%w: found duplicate content in %s", ErrBadTxtar, file.Name)
		}
		m[content] = true
	}
	return &txtarContent{
		data:       b,
		ResultType: resultType,
		archive:    archive,
	}, nil
}

// txtarContent represents a the contents of txtar archive. They cannot be
// rendered directly but are used with newRendererFromEvyBytes() when
// generating sub-questions.
type txtarContent struct {
	data       []byte
	ResultType ResultType
	archive    *txtar.Archive
}

// RenderOutput writes placeholder error message. It should never be called
// directly. txtarContent is mostly a placeholder for content creation in sub
// questions, but must satisfy the renderer interface with the current
// QuestionModel structure.
func (*txtarContent) RenderOutput() string {
	return "*** txtar Content ERROR ***"
}

// RenderHTML writes placeholder error message. See RenderOutput for further
// detail.
func (*txtarContent) RenderHTML(buf *bytes.Buffer) {
	buf.WriteString("*** txtar Content ERROR ***")
}

// TextContent represents plain text output of an Evy program.
type TextContent string

func newTextContent(cb *markdown.CodeBlock) TextContent {
	content := strings.Join(cb.Text, "\n") + "\n"
	return TextContent(content)
}

// RenderOutput returns the plain text output of an Evy program content as a
// string.
func (s TextContent) RenderOutput() string {
	return string(s)
}

// RenderHTML prints text output inside a <pre><code> element.
func (s TextContent) RenderHTML(buf *bytes.Buffer) {
	buf.WriteString("<pre><code>")
	buf.WriteString(string(s))
	buf.WriteString("</code></pre>\n")
}

func newRendererFromEvyFile(filename string, resultType ResultType) (Renderer, error) {
	if strings.HasSuffix(filename, ".txtar") {
		return newTxtarContent(filename, resultType)
	}
	b, err := os.ReadFile(filename)
	if err != nil {
		return nil, err
	}
	return newRendererFromEvyBytes(b, resultType), nil
}

func newRendererFromEvyBytes(b []byte, resultType ResultType) Renderer {
	switch resultType {
	case SVGOutput:
		content := runEvy(string(b), SVGOutput)
		return SVGContent(content)
	case TextOutput:
		content := runEvy(string(b), TextOutput)
		return TextContent(content)
	}
	return &evySource{source: string(b)}
}

func newRendererFromEvyBytesWithBlanked(b []byte, resultType ResultType) Renderer {
	src := string(b)
	switch resultType {
	case SVGOutput:
		content := runEvy(removeTaggedPrint(src), SVGOutput)
		return SVGContent(content)
	case TextOutput:
		content := runEvy(removeTaggedPrint(src), TextOutput)
		return TextContent(content)
	}
	return &evySource{source: string(b)}
}

func getResultTypeFromLink(link *markdown.Link) (ResultType, error) {
	u := link.URL
	if strings.HasPrefix(u, "https://") || strings.HasPrefix(u, "http://") {
		return UnknownOutput, fmt.Errorf("%w: found external link %q, expected relative link", ErrBadMarkdownStructure, u)
	}
	if !strings.HasSuffix(u, ".evy") && !strings.HasSuffix(u, ".txtar") {
		return UnknownOutput, fmt.Errorf("%w: found non evy link %q, expected .evy file", ErrBadMarkdownStructure, u)
	}
	if !strings.HasPrefix(link.Title, "evy:") {
		return UnknownOutput, fmt.Errorf("%w: found no evy title %q, expected evy:source | evy:svg | evy:text", ErrBadMarkdownStructure, link.Title)
	}
	switch strings.TrimPrefix(link.Title, "evy:") {
	case "text":
		return TextOutput, nil
	case "source":
		return UnknownOutput, nil
	case "svg":
		return SVGOutput, nil
	}
	return UnknownOutput, fmt.Errorf("%w: found invalid evy title %q, expected evy:source | evy:svg | evy:text", ErrBadMarkdownStructure, link.Title)
}

func toText(b markdown.Block) *markdown.Text {
	if t, ok := b.(*markdown.Text); ok {
		return t
	}
	if p, ok := b.(*markdown.Paragraph); ok {
		return p.Text
	}
	return nil
}

func resultTypeFromRenderer(r Renderer) ResultType {
	switch r := r.(type) {
	case SVGContent:
		return SVGOutput
	case TextContent:
		return TextOutput
	case *txtarContent:
		return r.ResultType
	}
	return UnknownOutput
}

func runEvy(source string, t ResultType) string {
	textWriter := &bytes.Buffer{}
	opts := []cli.Option{
		cli.WithSkipSleep(true),
		cli.WithOutputWriter(textWriter),
		cli.WithCls(textWriter.Reset),
		cli.WithSVG("", "", "" /* root style, width, height */),
	}
	rt := cli.NewPlatform(opts...)
	eval := evaluator.NewEvaluator(rt)
	err := eval.Run(source)
	if err != nil {
		return "**ERROR**"
	}
	if t == SVGOutput {
		imgWriter := &bytes.Buffer{}
		_ = rt.WriteSVG(imgWriter) // no error when writing to bytes.Buffer
		return imgWriter.String()
	}
	return textWriter.String()
}

func hasParseError(source string) bool {
	builtins := evaluator.BuiltinDecls()
	_, err := parser.Parse(source, builtins)
	return err != nil
}
