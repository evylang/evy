#!/usr/bin/env bash

main() {
	set -euo pipefail
	on_ci && set -x
	local channel result urls environ

	if (($# > 2)); then
		exit_error "usage [ENV=stage [CHANNEL=dev]]"
	fi

	on_ci && setup_ci_creds

	environ=$(get_environment "${1:-stage}") || exit $?
	channel=$(get_channel "${2:-}")
	rm -rf out/firebase
	cp -r firebase out/
	cp -r frontend out/firebase/public
	if [[ "${channel}" == "live" ]]; then
		hash_css_js out/firebase/public
		update_refs "${environ}"
		# `firebase deploy` must be used with live channel
		firebase --config out/firebase/firebase.json --project "${environ}" deploy --only hosting
		on_ci && make_env_urls "${environ}" >>"$GITHUB_ENV"
		exit 0
	fi

	# `firebase hosting:channel:deploy` must be used with preview/non-live channels
	result=$(firebase --json --config out/firebase/firebase.json --project "${environ}" hosting:channel:deploy "${channel}")
	check_deploy_error "${result}"
	urls=$(get_urls "${result}")
	printf "Deployed to \n%s\n" "${urls}"

	on_pr && post_pr_comment "${urls}"
	on_ci && make_pr_urls "${result}" >>"$GITHUB_ENV"
	exit 0
}

on_ci() {
	[[ -n "${CI:-}" ]]
}

on_pr() {
	on_ci && [[ "${GITHUB_REF:-}" == refs/pull/* ]]
}

setup_ci_creds() {
	if [ -z "${FIREBASE_SERVICE_ACCOUNT}" ]; then
		exit_error "FIREBASE_SERVICE_ACCOUNT environment variable must be set on CI."
	fi
	export GOOGLE_APPLICATION_CREDENTIALS=out/gac.json
	printenv FIREBASE_SERVICE_ACCOUNT >"${GOOGLE_APPLICATION_CREDENTIALS}"
}

get_environment() {
	local environ="$1"
	if [[ "${environ}" != "stage" && "${environ}" != "default" && "${environ}" != "prod" ]]; then
		exit_error "unknown environment: ${environ} (expected: stage, default or prod)"
	fi
	echo "${environ}"
}

get_channel() {
	local channel="$1"
	if [[ -n "${channel}" ]]; then
		echo "${channel}"
	elif on_pr; then
		get_pr_num
	elif on_ci; then
		echo "live"
	else
		echo "dev"
	fi
}

get_pr_num() {
	local pr_num=${GITHUB_REF:-unknown-pr} # GITHUB_REF == "refs/pull/:PR_NUM/merge"
	pr_num=${pr_num#refs/pull/}
	pr_num=${pr_num%/merge}
	echo "${pr_num}"
}

hash_css_js() {
	local dir="$1" files file hash hashed_file
	mapfile -t files < <(find "${dir}" -name '*.css' -o -name '*.js')
	for file in "${files[@]}"; do
		hash=$(get_hash "${file}")
		hashed_file="${file%.*}.${hash}.${file##*.}"
		mv "${file}" "${hashed_file}"
		ln -s "${hashed_file##*/}" "${file}"
	done
}

get_hash() {
	local file="$1"
	#  Hashes with 32 bits, or 8 chars[0-9a-f] and 100 file changes in a year
	#  (cache expiry is one year) has a collision probability of less than
	#  0.0000000005%.
	shasum -a 256 "${file}" | cut -c -8
}

# udpate_refs updates references in hrefs and src attributes and also
# generates an importmap in all **.html files in the frontend directory.
update_refs() {
	local environ="$1" domain="evystage.dev" file htmlfiles
	if [[ "${environ}" == "prod" ]]; then
		domain="evy.dev"
	fi
	echo "update hrefs for subdomains on $domain"
	mapfile -t htmlfiles < <(find frontend -name '*.html')
	for file in "${htmlfiles[@]}"; do
		update_refs_in_file "${domain}" "${file}"
	done
}

# update_refs_in_file updates references in hrefs and src attributes and also
# generates an importmap in given HTML file.
update_refs_in_file() {
	local domain="$1" file="$2" target cssfiles jsfiles modulefiles
	target="out/firebase/public/${file#frontend/}"

	# TODO this needs to be reworked for `../css/index.css` and other relative file paths.
	mapfile -t cssfiles < <(cd out/firebase/public && find css -name '*.*.css')
	mapfile -t jsfiles < <(cd out/firebase/public && find . -name '*.*.js' | cut -c3-)
	mapfile -t modulefiles < <(cd out/firebase/public && find ./module -name '*.*.js')
	update_subdomain_href "${domain}" <"${file}" |
		update_css_href "${cssfiles[@]}" |
		update_js_src "${jsfiles[@]}" |
		update_importmap "${modulefiles[@]}" \
			>"${target}"

	diff -u "${file}" "${target}" || true
}

# update_subdomain_href replaces hrefs and values starting
# with /discord, /docs, /learn or /play with the correct subdomain, e.g.:
#
#   href="/discord" -> href="https://discord.evy.dev"
update_subdomain_href() {
	local domain="$1"
	sed -E 's (href|value)="/(discord|docs|learn|play) \1="https://\2.'"${domain} g"
}

# update_css_href updates CSS file name links in the HTML contents provided
# on stdin and writes the result to stdout.
#
# update_css_href takes a list of target CSS file names with hashes as input.
# Filenames must match "NAME.HASH.css", e.g.: css/index.123bf.css.
# update_css_href replaces the the unhashed CSS file names with the hashes
# target CSS filenames:
#
#   target: css/index.123bf.css
#   source: css/index.css
#   match: <link rel="stylesheet" href="css/index.css" type="text/css" />
#
# Using hashed CSS filenames allows to set a long cache lifetime for CSS.
update_css_href() {
	local src target args=()
	for target in "$@"; do
		src="${target%.*.css}.css"
		args+=(-e "s href=\"${src}\" href=\"${target}\" ")
	done
	sed "${args[@]}"
}

# update_js_src updates JS file name src attributes in the HTML contents
# provided on stdin and writes the result to stdout.
#
# update_js_src takes a list of target JS file names with hashes as input.
# Filenames must match "NAME.HASH.js", e.g.: js/index.123bf.js.
# update_js_src replaces the the unhashed JS file names with the hashes
# target JS filenames:
#
#   target: js/index.123bf.js
#   source: js/index.js
#   match: <script src="js/index.js" type="module" defer></script>
#
# Using hashed JS filenames allows to set a long cache lifetime for JS.
update_js_src() {
	local src target args=()
	for target in "$@"; do
		src="${target%.*.js}.js"
		args+=(-e "s src=\"${src}\" src=\"${target}\" ")
	done
	sed "${args[@]}"
}

# update_importmap generates an [importmap] JSON and places it inside the
# matched `<script type="importmap></script>` tag.
#
# update_importmap takes a list of target JS file names with hashes as input.
# Filenames must match "js/NAME.HASH.css", e.g.: js/index.123bf.js. The
# unhashed import has the `js/` directory stripped:
#
#   target: js/index.123bf.js
#   source: index.js
#   match: <script type="importmap"></script>
#   generate:
#   {
#     "imports": {
#       "index.js": "js/index.123bf.js",
#       "yace-editor.js": "js/yace-editor-2346675.js"
#     }
#   }
#
# [importmap]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap
update_importmap() {
	local src target args=()
	for target in "$@"; do
		src="${target%.*.js}.js"
		src="${src#js/}"
		args+=("${src}" "${target}")
	done
	printf -v importmap '\\n    "%s": "%s",' "${args[@]}"
	importmap=${importmap%,}
	printf -v importmap '\\n{\\n  "imports": {%s\\n  }\\n}' "${importmap}"
	sed -e "s|^\( *\)<script type=\"importmap\"></script>|\1<script type=\"importmap\">${importmap//\\n/\\n\\1  }\n\1</script>|"
}

check_deploy_error() {
	local result="$1" status
	status=$(jq -r '.status' <<<"${result}")
	if [[ "${status}" == "error" ]]; then
		error_msg=$(jq -r '.error' <<<"${result}")
		exit_error "${error_msg}"
	fi
	if [[ "${status}" != "success" ]]; then
		exit_error "unknown status: ${result}"
	fi
}

# get_urls extracts key (target name) and URL from deployment result
#  For example get_urls called with the following deployment result:
#
#       {
#         "status": "success",
#         "result": {
#           "apex": {
#             "url": "https://evy-lang-stage--dev-hx5gnhrl.web.app",
#             //....
#           },
#           "docs": {
#             "url": "https://evy-lang-stage-docs--dev-d5kp6w0d.web.app"
#           },
#           // ...
#         }
#       }
#
#  returns
#
#      - apex: https://evy-lang-stage--dev-hx5gnhrl.web.app
#      - docs: https://evy-lang-stage-docs--dev-d5kp6w0d.web.app
get_urls() {
	local result="$1"
	jq -r '.result | to_entries[] | "- \(.key): \(.value.url)"' <<<"${result}"
}

post_pr_comment() {
	local urls="$1" sha body comment_id pr_num
	sha=$(git rev-parse "origin/${GITHUB_HEAD_REF}")
	body="firebase-deployment for ${sha}"
	body+=$'\n\n'
	body+="${urls}"
	body+=$'\n\n<!--- bot:firebase-urls --->' # marker to find correct comment for update
	pr_num=$(get_pr_num)

	comment_id=$(
		gh api -H "Accept: application/vnd.github+json" "/repos/evylang/evy/issues/${pr_num}/comments" |
			jq 'map(select(.body | contains ("<!--- bot:firebase-urls --->"))) | .[] .id' |
			head -n1
	)
	if [[ -z "${comment_id}" ]]; then
		# create new comment
		gh pr comment "${pr_num}" --body "${body}"
		return
	fi
	# update comment
	gh api --method PATCH -H "Accept: application/vnd.github+json" \
		"/repos/evylang/evy/issues/comments/${comment_id}" \
		-f body="${body}"
}

make_env_urls() {
	local env="$1"
	# Generate URLs for the deployment environment for a live firebase site, with an
	# APEX url and a bunch of subdomain URLS.

	local -A domains=([stage]=evystage.dev [prod]=evy.dev)
	local subdomains=(discord docs learn play)
	local domain="${domains[${env}]?"Unknown environment: '${env}'. Must be one of: ${!domains[*]}"}"

	printf 'BASEURL_APEX=https://%s\n' "${domain}"
	for sub in "${subdomains[@]}"; do
		printf 'BASEURL_%s=https://%s.%s\n' "${sub^^}" "${sub}" "${domain}"
	done
}

make_pr_urls() {
	local json_result="$1"
	# The following jq command generates the following output from a firebase deployment result:
	# BASEURL_APEX=https://evy-lang-stage--dev-mtnwzsbm.web.app
	# BASEURL_DISCORD=https://evy-lang-stage-discord--dev-pap726z0.web.app
	# BASEURL_DOCS=https://evy-lang-stage-docs--dev-62qb1rk7.web.app
	# BASEURL_LEARN=https://evy-lang-stage-learn--dev-txkb2kn8.web.app
	# BASEURL_PLAY=https://evy-lang-stage-play--dev-t9r8zjux.web.app
	jq -r '.result.[] | "BASEURL_\(.target | ascii_upcase)=\(.url)"' <<<"${json_result}"
}

exit_error() {
	echo "$*" >&2
	exit 1
}

# Only run main if executed as a script and not sourced.
if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then main "$@"; fi
