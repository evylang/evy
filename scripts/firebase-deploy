#!/usr/bin/env bash

main() {
	set -euo pipefail
	on_ci && set -x
	local channel result urls environ

	if (($# > 2)); then
		exit_error "usage [ENV=stage [CHANNEL=dev]]"
	fi

	on_ci && setup_ci_creds

	environ=$(get_environment "${1:-stage}") || exit $?
	channel=$(get_channel "${2:-}")
	if [[ "${channel}" == "live" ]]; then
		# `firebase deploy` must be used with live channel
		firebase --config firebase/firebase.json --project "${environ}" deploy --only hosting
		exit 0
	fi

	# `firebase hosting:channel:deploy` must be used with preview/non-live channels
	result=$(firebase --json --config firebase/firebase.json --project "${environ}" hosting:channel:deploy "${channel}")
	check_deploy_error "${result}"
	urls=$(get_urls "${result}")
	printf "Deployed to \n%s\n" "${urls}"

	on_ci && post_pr_comment "${urls}"
	exit 0
}

on_ci() {
	[[ -n "${CI:-}" ]]
}

setup_ci_creds() {
	if [ -z "${FIREBASE_SERVICE_ACCOUNT}" ]; then
		exit_error "FIREBASE_SERVICE_ACCOUNT environment variable must be set on CI."
	fi
	export GOOGLE_APPLICATION_CREDENTIALS=out/gac.json
	printenv FIREBASE_SERVICE_ACCOUNT >"${GOOGLE_APPLICATION_CREDENTIALS}"
}

get_environment() {
	local environ="$1"
	if [[ "${environ}" != "stage" && "${environ}" != "default" && "${environ}" != "prod" ]]; then
		exit_error "unknown environment: ${environ} (expected: stage, default or prod)"
	fi
	echo "${environ}"
}

get_channel() {
	local channel="$1"
	if [[ -n "${channel}" ]]; then
		echo "${channel}"
		return
	fi
	if [[ -z "${CI:-}" ]]; then
		echo "dev"
		return
	fi
	get_pr_num
}

get_pr_num() {
	local pr_num=${GITHUB_REF:-unknown-pr} # GITHUB_REF == "refs/pull/:PR_NUM/merge"
	pr_num=${pr_num#refs/pull/}
	pr_num=${pr_num%/merge}
	echo "${pr_num}"
}

check_deploy_error() {
	local result="$1" status
	status=$(jq -r '.status' <<<"${result}")
	if [[ "${status}" == "error" ]]; then
		error_msg=$(jq -r '.error' <<<"${result}")
		exit_error "${error_msg}"
	fi
	if [[ "${status}" != "success" ]]; then
		exit_error "unknown status: ${result}"
	fi
}

# get_urls extracts key (target name) and URL from deployment result
#  For example get_urls called with the following deployment result:
#
#       {
#         "status": "success",
#         "result": {
#           "apex": {
#             "url": "https://evy-lang-stage--dev-hx5gnhrl.web.app",
#             //....
#           },
#           "docs": {
#             "url": "https://evy-lang-stage-docs--dev-d5kp6w0d.web.app"
#           },
#           // ...
#         }
#       }
#
#  returns
#
#      - apex: https://evy-lang-stage--dev-hx5gnhrl.web.app
#      - docs: https://evy-lang-stage-docs--dev-d5kp6w0d.web.app
get_urls() {
	local result="$1"
	jq -r '.result | to_entries[] | "- \(.key): \(.value.url)"' <<<"${result}"
}

post_pr_comment() {
	local urls="$1" sha body comment_id pr_num
	sha=$(git rev-parse "origin/${GITHUB_HEAD_REF}")
	body="firebase-deployment for ${sha}"
	body+=$'\n\n'
	body+="${urls}"
	body+=$'\n\n<!--- bot:firebase-urls --->' # marker to find correct comment for update
	pr_num=$(get_pr_num)

	comment_id=$(
		gh api -H "Accept: application/vnd.github+json" "/repos/evylang/evy/issues/${pr_num}/comments" |
			jq 'map(select(.body | contains ("<!--- bot:firebase-urls --->"))) | .[] .id' |
			head -n1
	)
	if [[ -z "${comment_id}" ]]; then
		# create new comment
		gh pr comment "${pr_num}" --body "${body}"
		return
	fi
	# update comment
	gh api --method PATCH -H "Accept: application/vnd.github+json" \
		"/repos/evylang/evy/issues/comments/${comment_id}" \
		-f body="${body}"
}

exit_error() {
	echo "$*" >&2
	exit 1
}

# Only run main if executed as a script and not sourced.
if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then main "$@"; fi
